# Глава 9. Задачи за шампиони (част I)

В настоящата глав ще предложим на читателя няколко малко по-трудни задачи, които имат за цел да развият алгоритмични умения и програмни техники за решаване на задачи с по-висока сложност. Задачите са върхи изучавания в книгата учебен материал, но по трудност надвишават обучайните задачи от приемните изпити в СофтУни. Ако искате да сте шампиони по основи на програмирането, ви препоръчваме да се научите да решавате такива по-сложни задачи, за да ви е лесно по изпитите.

## Crossing sequences (Пресичащи се редици)

Имаме две редици: __редица на Трибоначи__, където всяко число е сумата от предните три и __числовата спирала__, дефинирана чрез обхождане на матрица от числа като спирала(дясно, долу, ляво, горе, дясно, долу, горе, ляво, ...) и записване на текущите числа, всеки път когато направим завой. Намерете първото число което се появява и в двете последователности.

### Пример

<img src="assets/chapter-9-images/1_spiral.png" alt="Пример числова спирала" title="Числова спирала" style="float: right; height: 250px;" />

Нека редицата на Трибоначи да започне с 1, 2 и 3. Това означава че ще съдържа числата 1, 2, 3, 6, 11, 20, 37, 68, 125, 230, 423, 778, 1431, 2632, 4841, 8904, 16377, 30122, 55403, 101902, и т.н.

Също така, нека числата в спиралата да започнат с 5 и да се увеличава 2 на всяка стъпка, тогава ще съдържа числата 5, 7, 9, 13, 17, 23, 29, 37, т.н. Тъй като 37 е първото число, което се среща в редицата на Трибоначи и в спиралта, това е отговорът.
<!-- ![Пример числова спирала](assets/chapter-9-images/1_spiral.png "Числова спирала") -->

### Входни данни

Входните данни трябва да бъдат прочетени от кознолата.
* На първите три реда от входа, ще прочетете __три цели числа__, представляващи първите три числа в редицата на Трибоначи.
* На следващите два реда от входа, ще прочетете __две цели числа__, представляващи първото число и стъпката за всяка клетка на матрицата за спиралата от числа.

Входящите данни винаги ще бъдат валидни и винаги ще са в описания формат.  Няма нужда да ги проверявате.

### Изходни данни

Резултатът трябва да бъде принтиран на козолата.

На единствения ред от изхода трябва да принтирате __най-малкото число, което се среща и в двете последователности__. Ако няма число в __диапазона [1...1 000 000]__, което да се среща и в двете последователности, принтирайте "__No__".

### Ограничения

* Всички числа във входа ще бъдат в диапазона [1...1 000 000].
* Позволено работно време за програмта: 0.25 секунди.
* Позволена памет: 16 MB.

### Примерен вход и изход

| Вход | Изход  || Вход | Изход      |
|------|--------||------|------------|
| 1    | 37     || 13   | 13         |
| 2    | &nbsp; || 25   | &nbsp;     |
| 3    | &nbsp; || 99   | &nbsp;     |
| 5    | &nbsp; || 5    | &nbsp;     |
| 2    | &nbsp; || 2    | &nbsp;     |


| Вход | Изход  || Вход | Изход      |
|------|--------||------|------------|
| 1    | 1      || 4    | 71         |
| 1    | &nbsp; || 1    | &nbsp;     |
| 1    | &nbsp; || 7    | &nbsp;     |
| 1    | &nbsp; || 23   | &nbsp;     |
| 1    | &nbsp; || 3    | &nbsp;     |

| Вход | Изход  |
|------|--------|
| 99   | No     |
| 99   | &nbsp; |
| 99   | &nbsp; |
| 2    | &nbsp; |
| 2    | &nbsp; |

### Насоки и подсказки

#### Обработване на входа

Първа стъпка от решаването на задачата е да прочетем и обработим на входа. Входните данни се състоят от 5 цели числа - 3 за редицата на Трибоначи и 2 за числовата спирала.

![Пример четене от конзолата](assets/chapter-9-images/1_input.png "Четене от конзолата")

След като имаме входните данни е хубаво да видим как ще генерираме числа в двете редици.

#### Генериране на редица на Трибоначи

За редицата на Трибоначи, това което трябва да правим всеки път е да събираме предните три стойности и след това да отместим стойностите на трите предишни числа с една позиция напред в редицата т.е. стойността на първото трябва да приеме стойността на второто и т.н.

![Пример генериране число за редицата на  Трибоначи](assets/chapter-9-images/1_tribonacci.png "Генериране на число за редицата на Трибоначи")

#### Генериране на числова спирала

Трябва да измилим зависимост между числата в числовата спирала, за да можем да лесно да генерираме всяко следващо число без да се налага да разглеждаме матрици и тяхното обхождане. Ако разгледаме внимателно картинката от условието можем да забележим, че на всеки 2 "завоя" в спиралата числата, които прескачаме се увеличават с 1 т.е. от 5 до 7 и от 7 до 9 не се прескача нито 1 число, ами директно събираме със стъпката на редицата. От 9 до 13 и от 13 до 17 прескачаме едно число т.е. събираме два пъти стъпката. От 17 до 23 и от 23 до 29 прескачаме две числа т.е. събираме три пъти стъпката и т.н.

Така виждаме, че при първите две имаме последното числото + 1\*стъпката, следващите две имат 2\*стъпката и т.н.
Всеки път когато искаме следващото число от сиралата ще трябва да извършваме такава сметка.

![Пример генериране число за числовата спирала](assets/chapter-9-images/1_gen_spiral.png "Генериране на число за числовата спирала")

Това, което трябва да се погрижим е на всеки две числа нашият умножител(може да го наречем коефициент) да се увеличава с 1, което може да се постигне с просто условие от рода на:

![Пример условие за увеличване на коефициента на спиралата](assets/chapter-9-images/1_spiral_step_inc.png "Условие за увеличаване на коефициента")

#### Намиране на общо число за двете редици

След като знаем как да генерираме числа и в двете редици можем да пристъпим към обединението им и реално изграждането на крайното решене. Как ще изглежда нашето то - на всяка стъпка ще проверяваме дали числата от двете редици съвпадат, ако това е така ще принтираме на конзолата числото и ще прекратим изпълнението на нашата фунцкия. В противен случай ще видим текущото число, на коя редица е по-малко и ще генерираме следващото, там където "изоставаме". Идеята е, че ще се надяваме при генериране на следващо число да постигнем равенство, а ако нямаме отново ще изпълним горните стъпки.

Знаем, че по условие имаме ограничението, че числата от редиците ще бъдат в диапазона от 1 до 1 000 000. Следователни и ние ще генерираме числа само в този диапазон. Структурата на нашето решение ще изглежда така

![Структура на решението](assets/chapter-9-images/1_solution_structure.png "Структура на решението")

Преди показания `while` цикъл ще трябва да инициализирате променливите `spiralIncrement`, `spiralStepMul`, `spiralCurrent` и `tribonacciCurrent`. Много внимавайте с подбора на начална стойност за `tribonacciCurrent`, защото това може да доведе до пропускане на стойности и липса на точки в judge. След като цялото решение е готово опитайте с различни начални стойности и се опитайте да си обясните от къде идват разликите в точките.

Решението към момента би трябвало да ни дава точки, но със сигурност не и 100. Какво проускаме? Пропускаме факта, че още в началото началното число на спиралата може да бъде равно на някое от трите начални числа от редицата на Трибоначи.

![Подобрено условие за пресичащи се редици](assets/chapter-9-images/1_improved_if.png "Подобрено условие за пресичащи се редици")

#### Финални щрихи

Последното нещо, което все още не сме обработили е случаят, в който няма нито едно намерено число, което да съвпада. След изпълнението на нашия `while` цикъл трябва да добавим `Console.WriteLine("No");`. Моля обърнете внимание, че когато принтираме, защото сме намерили съвадащ числа е важно да прекратим изпълнението на цялата програма, а не само на нашия цикъл, защото може да получим извеждане на `No` всеки път, а не само когато няма принтирано число.

### Тестване в Judge системата

Линк към задачата в Judge системата: https://judge.softuni.bg/Contests/Practice/Index/5#3

## Magic Dates (Магически дати)

Да приемем, че ни е зададена __дата__ във формат дд-мм-гггг, например 17-03-2007. Изчисляваме __теглото на тази дата__ като вземем всичките ѝ цифри, умножим всяка цифра с останалите и накрая съберем всички получени резултати. В нашия случай имаме 8 цифри: 17032007, така че теглото е  1\*7 + 1\*0 + 1\*3 + 1\*2 + 1\*0 + 1\*0 + 1\*7 + 7\*0 + 7\*3 + 7\*2 + 7\*0 + 7\*0 + 7\*7 + 0\*3 + 0\*2 + 0\*0 + 0\*0 + 0\*7 + 3\*2 + 3\*0 + 3\*0 + 3\*7 + 2\*0 + 2\*0 + 2\*7 + 0\*0 + 0\*7 + 0\*7 = 144.

Вашата задача е да напишете програма, която намира всички __магически дати: дати между две определени години отговарящи на дадено магическо тегло__. Датите трябва да бъдат принтирани в нарастващ ред във формат дд-мм-гггг. Ще използваме традиционен календар (годините имат 12 месеца, всеки месец има 28, 29, 30 или 31 дни, т.н.)

### Входни данни

Входните данни трябва да бъдат прочетени от конзолата. Състоят се от 3 реда:

*	Първият ред съдържа цяло число - __начална година__
*	Вторият ред съдържа цяло число - __крайна година__
*	Третият ред съдържа цяло число - __магическо тегло__

Входящите данни винаги ще бъдат валидни и винаги ще са в описания формат. Няма нужда да ги проверявате.

### Изходни данни

Резултатът трябва да бъде принтиран на козолата, като последователни дати във __формат дд-мм-гггг__ подредени по азбучен ред. Всеки низ трябва да е на отделен ред. В случай че няма съществуващи магически дати, принтира "__No__".

### Ограничения

* Началната и крайната година са цели числа в периода [1900-2100].
* Магическото тегло е цяло число в диапазона [1...1000].
* Позволено работно време за програмта: 0.25 секунди.
* Позволена памет: 16 MB.


### Примерен вход и изход

| Вход | Изход      || Вход | Изход      |
|------|------------||------|------------|
| 2007 | 17-03-2007 || 2003 | No         |
| 2007 | 13-07-2007 || 2004 |            |
| 144  | 31-07-2007 || 1500 | &nbsp;     |


| Вход | Изход      |
|------|------------|
| 2012 | 09-01-2013 |
| 2014 | 17-01-2013 |
| 80   | 23-03-2013 |
|      | 11-07-2013 |
|      | 01-09-2013 |
|      | 10-09-2013 |
|      | 09-10-2013 |
|      | 17-10-2013 |
|      | 07-11-2013 |
|      | 24-11-2013 |
|      | 14-12-2013 |
|      | 23-11-2014 |
|      | 13-12-2014 |
|      | 31-12-2014 |

| Вход | Изход      |
|------|------------|
| 2011 | 01-01-2011 |
| 2012 | 10-01-2011 |
| 14   | 01-10-2011 |
|      | 10-10-2011 |

### Насоки и подсказки

Започваме от входните данни. В случая имаме 3 цели числа, които трябва да се прочетата от конзолата, като с това се изчерпва въвеждането и обработването на входа за задачата.

Разполагайки с началната и крайната година е хубаво да разберем как ще минем през всяка дата, без да се объркваме от това колко дена има в месеца, дали е високосна година и т.н.

#### Обхождане на всички дати

За обхождането ще се възползваме от функционалността, която ни дава `DateTime` класът. За начало ще си дефинираме променлива, за началната дата, което можем да направим използвайки конструктора, който приема година, месец и ден. Знаем, че годината е началната година, която сме прочели от конзолата, а месеца и деня трябва да са съответно януари и 1ви.

![Иницализация на началната дата](assets/chapter-9-images/2_init_datetime.png "Инициализация на началната дата")

След като имаме началната дата искаме да направим цикъл, който се изпълнява, докато не превишим крайната година(или докато не преминем 31 декември в крайната година), като на всяка стъпка увеличава с по 1 ден.

За да увеличаваме с 1 ден при всяко завъртане ще използваме метода от `DateTime` - `AddDays`, който добавя брой дни към текущата дата и връща новополучената(**Note:** тъй като методът връща "новата" дата е важно да имаме присвояване, а не само извикване на метода). Методът ще се грижи вместо нас, кога трябва да прескочи в следващия месец, колко дни има даден месец и всичко останало.

В крайна сметка нашият цикъл може да изглежда по следния начин

![Цикъл обикалящ всички дни](assets/chapter-9-images/2_dates_loop.png "Цикъл обикалящ всички дни")

*Note: Може да постигнете същия резултат с `for` цикъл, инициализацията на датата отива в първата част на `for`, условието се запазва, а стъпката е увеличаването с 1 ден. Също така условието може да се замени като се направи променлива за крайната дата т.е. 31 декември в крайната година и да се сравняват директно двете дати*

#### Пресмятане на теглото

Всяка дата се състои от точно 8 символа(цифри) - 2 за деня, 2 за месеца и 4 за годината. Това означава, че всеки път ще имаме една и съща сметка и може да се възползваме от това, за да дефинираме сметката статично(т.е. да не обикаляме с цикли, реферирайки различни цифри от датата, а да изпишем цялата сметка). За да успеем да изпишем формулата ще ни трябват всички цифри от датата в отделни променливи, за да направим всички нужни умножения. Използвайки операциите деление и деление върху отделните компоненти на датата, а именно `Day`, `Month` и `Year` можем да извлечем всяка цифра.

![Взимане на отделните цифри от дата](assets/chapter-9-images/2_digit_getting.png "Взимане на отделните цифри от дата")

Остава да направим сметката, която ще ни даде магическото тегло на дадена дата. За да не изписваме всички умножения, както е показано в примера ще приложим просто групиране. Това, което трябва да направим е да умножим всяка цифра с тези, които са след нея. Вместо да изписваме `d1 * d2 + d1 * d3 ... + d1 * d8`, може да съкратим този израз като `d1 * (d2 + d3 ... + d8)`, следвайки математическите правила за групиране, когато имаме умножение и събиране. Прилагайки същото опростяване за останалите умножения получаваме следната формула

![Пресмятане на теглото](assets/chapter-9-images/2_sum_weight.png "Пресмятане на теглото")

#### Изход

След като имаме пресметнато теглото на дадена дата, трябва да проверим дали съвпада с търсеното от нас магическо тегло, за да знаем, дали трябва да се принтира или не. Проверката може да се направи със стандарен `if`, като трябва да се внимава при принтирането, датата да е в правилния формат. Тук може да имате два подхода.
Първият начин е да използваме метода `ToString`, на който можем да му подадем формат на дадата т.е. дали дните да се изписват с водеща нула или не, дали месеците да се изписват с водещи нули или не, с думи или с цифри, с кратък запис или с пълно име и т.н.

![Принтиране на дата чрез ToString](assets/chapter-9-images/2_date_to_string.png "Принтиране на дата чрез ToString")

Вторият вариант е да вземем отделните компоненти на датата `Day`, `Month` и `Year`, както направихме при пресмятането и да си оформим изхода чрез форматиращ стринг.

![Принтиране на дата чрез форматиращ стринг](assets/chapter-9-images/2_date_format.png "Принтиране на дата чрез форматиращ стринг")

Тъй като обхождаме датите от началната година към крайната те винаги ще бъдат подредени във възходящ ред.

#### Финални щрихи

Остава едно условие, за да може задачата да е напълно завършена. Ако няма нито една дата, която да е с подаденото тегло трябва да принтираме `No`. За целта ще добавим един флаг(променлива от булев тип) `printed`, на който ще дадем стойност `true`, когато влезем в условието за принтиране и начална стойност `false`.
В края на задача ще добавим следното условие, за да принтираме `No` при нужда.

![Принтиране на "No"](assets/chapter-9-images/2_output_no.png "Принтиране на "No"")

### Тестване в Judge системата

Линк към задачата в Judge системата: https://judge.softuni.bg/Contests/Practice/Index/6#3

## Five Special Letters (Пет специални букви)

Дадени са две числа: __начало__ и __край__. Напишете програма, която __генерира всички комбинации от 5 букви__, всяка от групата {'a', 'b', 'c', 'd', 'e'}, така че теглото на тези 5 букви да е число в интервала [начало...край], включително. Принтирайте ги по азбучен ред, на един ред, разделени с пространство.

__Теглото на една буква__ е изчислено по следния начин: weight('__а__') = __5__; weight('__b__') = __-12__; weight('__c__') = __47__; weight('__d__') = __7__; weight('__e__') = __-32__. __Теглото на редицата__ от букви c1c2…cn е изчислено като се премахват всички букви, които се повтарят (от дясно наляво) и след това се сметне формулата:

<center>weight(c1c2…cn) = 1\*weight(c1) + 2\*weight(c2) + … + n\*weight(cn)</center><br/>
Например, теглото на "bcddc" се изчислява по следния начин:  Първо премахваме повтарящите се букви и получаваме "bcd". След това прилагаме формулата: 1\*weight('b') + 2\*weight('c') + 3\*weight('d') = 1\*(-12) + 2\*47 + 3\*7 = 103. Друг пример: weight("cadea") = weight("cade") = 1\*47 + 2\*5 + 3\*7 - 4\*32 = -50.

### Входни данни

Входните данни трябва да бъдат прочетени от кознолата. Състоят се от два реда:
* Числото за __начало__ е на първия ред.
* Числото за __край__ е на втория ред.

Входните данни винаги ще бъдат валидни и винаги ще са в описания формат. Няма нужда да ги проверявате.

### Изходни данни

Резултатът трябва да бъде принтиран на козолата като поредица от низове, __подредени по азбучен ред__. Всеки низ трябва да бъде отделен от следващия с едно разстояние. Ако теглото на нито един от 5 буквените низове не съществува в зададения интервал, принтирайте "__No__"

### Ограничения

* Числата за __начало__ и __край__ да бъдат цели числа в диапазона [-10000...10000].
* Позволено работно време за програмта: 0.25 секунди.
* Позволена памет: 16 MB.

### Примерен вход и изход

| Вход | Изход       | Коментар             |
|------|-------------|----------------------|
| 40   | bcead bdcea | weight("bcead") = 41 |
| 42   | &nbsp;      | weight("bdcea") = 40 |

| Вход | Изход         |
|------|---------------|
| -1   | bcdea cebda eaaad eaada eaadd eaade eaaed eadaa eadad eadae eadda eaddd eadde eadea eaded eadee eaead eaeda eaedd eaede eaeed eeaad eeada eeadd eeade eeaed eeea |
| 1    | &nbsp;        |

| Вход | Изход      |
|------|------------|
| 200  | baadc babdc badac badbc badca badcb badcc badcd baddc bbadc bbdac bdaac bdabc bdaca bdacb bdacc bdacd bdadc bdbac bddac beadc bedac eabdc ebadc ebdac edbac   |
| 300  | &nbsp;     |

| Вход | Изход  |
|------|--------|
| 300  | No     |
| 400  | &nbsp; |

### Насоки и подсказки

Като всяка задача, започваме решението с прочитане и обработване на входните данни. В случая имаме две цели числа, които можем да обработим с комбинация от методите `int.Parse` и `Console.ReadLine`. Приемайки, че имаме двете цели числа в нашето приложение можем да продължим нататък.

В задачата имаме няколко основни момента - генерирането на всички комбинации с дължина 5 включващи 5те дадени букви, премахването на повтарящите се букви и пресмятането на теглото за дадена вече опростена дума.

#### Генериране на всички комбинации

Преди да стигнем до генериране на стрингове с дължина ще разгледаме малко по-прости примери.
За да генерираме всички комбинации с дължина 1 използвайки 5 символа бихме използвали 1 цикъл от 1..5, като всяко число от цикъла ще искаме да отговаря на един символ. За да генерираме всички комбинации с дължина 2 използвайки 5 символа бихме направили два вложени цикъла всеки обхождащ цифрите от 1 до 5, като отново ще направим така че всяка цифра да отговаря на конкретен символ. По същата схема бихме продължили да добавяме цикли за всяка единица дължина, която добавяме(ако имате съмнения как ще се обходяд всички комбинации тествайте с дължина 1 и 2, принтирайки просто индексите, за да видите какъв е резултата).

![Генериране на комбинации](assets/chapter-9-images/3_gen_combinations.png "Генериране на комбинации")

Имайки всички 5-цифрени комбинации, трябва да намерим начин да "превърнем" петте цифри в дума с буквите от 'a' до 'e'. Един от начините да го направим е, като си предефинираме прост стринг съдържаш буквите, които имаме

![Стринг с всички букви](assets/chapter-9-images/3_pattern_string.png "Стринг с всички букви")

и за всяка цифра взимаме буквата от конкретната позиция. Така числото 00000 ще стане "aaaaa", чилото 02423 ще стане "acecd". Можем да напрвим стринга от 5 букви по следния начин

![Преобразуване на индекси до букви](assets/chapter-9-images/3_indexes_to_letters.png "Преобразуване на индекси до букви")

_Note: Можем да преобразуваме цифрите до букви, използвайки това, че буквите са подредени в `ascii` таблицата. Изразът `'а' + i` ще ни даде резултата 'a', ако `i` е равно на 0, 'c', ако `i` е равно на 2 и т.н._

Така имаме всички 5-буквени комбинации и можем да продължим със следващата част от задачата! Тъй като сме подбрали `pattern` и циклите по подходящ начин обикаляме думите в азбучен ред и няма нужда от допълнително сортиране при извеждане.

#### Премахването на повтарящи се букви

След като имаме вече готовия стринг трябва да премахнем всички повтарящи се символи от дясно наляво. Ще направим тази операция, като добавяме буквите от ляво надясно в нов стринг и всеки път преди да добавим буква ще проверяваме дали вече я има - ако я има ще я пропускаме, а ако я няма ще я добавяме.
За начало ще добавим първата буква към началния стринг.

![Добавяне на първата буква към стринга с уникални букви](assets/chapter-9-images/3_add_first_to_unique.png "Добавяне на първата буква към стринга с уникални букви")

След това ще обиколим останалите 4 с цикъл проверявайки всеки път дали ги има със следното условие и метода `IndexOf`.

![Добавяне на първата буква към стринга с уникални букви](assets/chapter-9-images/3_indexof_cond.png "Добавяне на първата буква към стринга с уникални букви")

Методът `IndexOf` връща индексът на конкретния елемент, ако бъде намерен или `-1`, ако елементът не бъде намерен. Следователно всеки път, когато получим `-1` ще означава, че все още нямаме тази буква в новия стринг с уникални букви и можем да я добавим на спокойствие, а ако получим стойност различна от `-1` ще означава, че вече имаме буквата и няма да я добавяме.

#### Пресмятане на теглото

Пресмятането на теглото е просто обхождане на уникална дума, получена в миналата стъпка, като за всяка буква трябва да вземем теглото и и да я умножим по позицията. За всяка буква в обхождането трябва да пресметнем с каква стойност ще умножим позицията и. Най-лесно това би станало чрез използването на `switch`.

![Switch за тежестите на буквите](assets/chapter-9-images/3_letter_switch.png "Switch за тежестите на буквите")

И когато имаме стойността на дадената буква следва да умножим по позицията  ѝ. Тъй като индексите в стринга се различават с 1 от реалните позиции т.е. индекс 0 е позиция 1, индекс 1 е позиция 2 и т.н., ще добавим 1 към индексите.

![Умножение за получаване на тежестта](assets/chapter-9-images/3_weight_calc.png "Умножение за получаване на тежестта")

Всички получени междинни резултати трябва да бъдат добавени към обща сума за всяка една 5-буквена комбинация.

#### Оформяне на изхода

Дали дадена дума трябва да се принтира се определя по нейната тежест. Трябва ни условие, което да определи дали текущата тежест е в интервала [начало..край] подаден ни на входа в началото на програмата. Ако това е така принтираме **пълната** дума(внимавайте да не принтирате думата от уникални букви. Тя ни бе необходима само за пресмятане на тежестта)! Думите са разделени с интервал, затова внимавайте при изписването на конзолата да използвате `Write` метода вместо `WriteLine`.


![Оформяне на изхода](assets/chapter-9-images/3_output.png "Оформяне на изхода")

#### Финални щрихи

Условието е изпълнено с изключение случаите в които нямам нито една дума в подадения интервал. За да разберем дали сме принтирали просто ще добавим един флаг(променлива от булев тип) `printed`, на който ще дадем стойност `true`, когато влезем в условието за принтиране и начална стойност `false`.
За да бъде изпълнена цялата задача трябва да добавим следното условие на края на нашата задача

![Принтиране на "No"](assets/chapter-9-images/3_output_no.png "Принтиране на "No"")

### Тестване в Judge системата

Линк към задачата в Judge системата: https://judge.softuni.bg/Contests/Practice/Index/7#3
